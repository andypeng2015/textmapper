// generated by Textmapper; DO NOT EDIT

#include "json_lexer.h"

#include "absl/log/log.h"
#include "absl/strings/match.h"

namespace json {
namespace {
constexpr int tmNumClasses = 29;

constexpr uint8_t tmRuneClass[] = {
    1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  2,  1,  1,  2,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  4,  5,  1,  1,
    1,  1,  1,  1,  6,  7,  8,  9,  10, 11, 12, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 14, 1,  1,  1,  1,  1,  1,  15, 16, 16, 16, 17, 16, 18, 18, 18, 18, 18,
    18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 1,
    1,  1,  16, 22, 16, 16, 17, 22, 18, 18, 18, 18, 18, 18, 18, 23, 18, 18, 18,
    23, 18, 23, 24, 18, 18, 18, 18, 18, 25, 1,  26, 1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  27, 1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  28,
};

constexpr int tmRuneClassLen = 207;
constexpr int tmFirstRule = -3;

constexpr int tmStateMap[] = {
    0,
    32,
};

constexpr int8_t tmToken[] = {
    1, 0, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 17,
};

constexpr int8_t tmLexerAction[] = {
    -3,  -3,  31,  -3,  24,  -3,  -3,  -3,  23,  22,  -3,  18,  17,  11,  10,
    8,   7,   7,   7,   6,   -3,  5,   7,   7,   7,   4,   3,   -3,  1,   -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  2,   -3,  -20, -20,
    -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20,
    -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -20, -6,  -6,  -6,
    -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,
    -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -6,  -5,  -5,  -5,  -5,
    -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,
    -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -5,  -8,  -8,  -8,  -8,  -8,
    -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,
    -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -8,  -7,  -7,  -7,  -7,  -7,  -7,
    -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,
    -7,  -7,  -7,  -7,  -7,  -7,  -7,  -7,  -16, -16, -16, -16, -16, -16, -16,
    -16, -16, -16, -16, -16, 7,   7,   -16, 7,   7,   7,   7,   -16, -16, -16,
    7,   7,   7,   -16, -16, -16, -16, -16, -16, -16, 9,   -16, -16, -16, -16,
    -16, -16, -16, -16, 7,   7,   -16, 7,   7,   7,   7,   -16, -16, -16, 7,
    7,   7,   -16, -16, -16, -16, -22, -22, -22, -22, -22, -22, -22, -22, -22,
    -22, -22, -22, -22, -22, -22, -22, -22, -22, -22, -22, -22, -22, -22, -22,
    -22, -22, -22, -22, -22, -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,
    -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,  -9,
    -9,  -9,  -9,  -9,  -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -1,
    -15, 11,  11,  -15, -15, -15, -2,  -15, -15, -15, -15, -15, -15, -15, -15,
    -15, -15, -15, -3,  -3,  -3,  -3,  -3,  -3,  -3,  14,  -3,  14,  -3,  -3,
    13,  13,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, 13,
    13,  -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15,
    -15, -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  13,  13,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  16,  16,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -15,
    -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, 16,  16,  -15, -15,
    -15, -2,  -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15,
    -15, -15, -15, -15, -15, -15, -15, -15, -1,  -15, -15, -15, -15, -15, -15,
    -2,  -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -15, -3,  -3,  -3,
    -3,  -3,  -3,  19,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  19,  19,  19,
    19,  19,  20,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  19,  -3,  19,  19,  19,  19,
    19,  20,  19,  19,  19,  19,  21,  19,  19,  19,  19,  19,  19,  19,  19,
    19,  19,  19,  19,  19,  19,  19,  19,  19,  -13, -13, -13, -13, -13, -13,
    -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13, -13,
    -13, -13, -13, -13, -13, -13, -13, -13, -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  17,  11,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -10, -10, -10, -10, -10, -10, -10, -10,
    -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10, -10,
    -10, -10, -10, -10, -10, -10, -3,  24,  24,  24,  30,  24,  24,  24,  24,
    24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  24,  25,  24,  24,  24,
    24,  24,  24,  24,  24,  -3,  -3,  -3,  -3,  24,  -3,  -3,  -3,  -3,  -3,
    -3,  24,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  24,  -3,  24,  24,  26,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    -3,  27,  27,  -3,  27,  27,  27,  -3,  -3,  -3,  -3,  27,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,
    28,  28,  -3,  28,  28,  28,  -3,  -3,  -3,  -3,  28,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  29,
    29,  -3,  29,  29,  29,  -3,  -3,  -3,  -3,  29,  -3,  -3,  -3,  -3,  -3,
    -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  -3,  24,  24,
    -3,  24,  24,  24,  -3,  -3,  -3,  -3,  24,  -3,  -3,  -3,  -3,  -3,  -3,
    -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14,
    -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -14, -12,
    -12, 31,  -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12,
    -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -12, -3,  -3,
    31,  -3,  24,  33,  -3,  -3,  23,  22,  -3,  18,  17,  11,  10,  8,   7,
    7,   7,   6,   -3,  5,   7,   7,   7,   4,   3,   -3,  1,   -11, -11, -11,
    -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11,
    -11, -11, -11, -11, -11, -11, -11, -11, -11, -11, -11,
};

constexpr int tmBacktracking[] = {
    12, 15,  // in JSONNumber
    12, 12,  // in JSONNumber
};
}  // namespace

Lexer::Lexer(absl::string_view input_source) {
  source_ = input_source;
  if (absl::StartsWith(source_, bomSeq)) {
    offset_ += bomSeq.size();
  }
  Rewind(offset_);
}

Token Lexer::Next() {
restart:
  token_line_ = line_;
  token_column_ = offset_ - line_offset_ + 1;
  token_offset_ = offset_;

  int state = tmStateMap[static_cast<uint32_t>(start_state_)];
  uint32_t hash = 0;
  int backupRule = -1;
  uint64_t backupOffset;
  uint32_t backupHash = hash;
  while (state >= 0) {
    int curr_class;
    if (input_rune_ < 0) {
      state = tmLexerAction[state * tmNumClasses];
      if (state > tmFirstRule && state < 0) {
        state = (-1 - state) * 2;
        backupRule = tmBacktracking[state];
        backupOffset = offset_;
        backupHash = hash;
        state = tmBacktracking[state + 1];
      }
      continue;
    } else if (input_rune_ < tmRuneClassLen) {
      curr_class = tmRuneClass[input_rune_];
    } else {
      curr_class = 1;
    }
    state = tmLexerAction[state * tmNumClasses + curr_class];
    if (state > tmFirstRule) {
      if (state < 0) {
        state = (-1 - state) * 2;
        backupRule = tmBacktracking[state];
        backupOffset = offset_;
        backupHash = hash;
        state = tmBacktracking[state + 1];
      }
      hash = hash * 31 + static_cast<uint32_t>(input_rune_);
      if (input_rune_ == '\n') {
        line_++;
        line_offset_ = offset_;
      }

      // Scan the next character.
      offset_ = scan_offset_;
      if (offset_ < source_.size()) {
        input_rune_ = static_cast<unsigned char>(source_[scan_offset_++]);
      } else {
        input_rune_ = -1;
      }
    }
  }

  int rule = tmFirstRule - state;
recovered:
  switch (rule) {
    case 13:
      switch (hash & 7) {
        case 1:
          if (hash == 0x41 && "A" == Text()) {
            rule = 17;
            break;
          }
          break;
        case 2:
          if (hash == 0x42 && "B" == Text()) {
            rule = 18;
            break;
          }
          break;
        case 3:
          if (hash == 0x5cb1923 && "false" == Text()) {
            rule = 16;
            break;
          }
          break;
        case 6:
          if (hash == 0x36758e && "true" == Text()) {
            rule = 15;
            break;
          }
          break;
        case 7:
          if (hash == 0x33c587 && "null" == Text()) {
            rule = 14;
            break;
          }
          break;
      }
      break;
    default:
      break;
  }

  Token tok = Token(tmToken[rule]);
  bool space = false;
  switch (rule) {
    case 0:
      if (backupRule >= 0) {
        rule = backupRule;
        hash = backupHash;
        Rewind(backupOffset);
      } else if (offset_ == token_offset_) {
        if (input_rune_ == -1) {
          tok = Token::EOI;
        }
        Rewind(scan_offset_);
      }
      if (rule != 0) {
        goto recovered;
      }
      break;
    case 9:  // space: /[\t\r\n ]+/
      space = true;
      break;
    case 19:  // 'A': /A!/
    {         /*some code */
    } break;
  }
  if (space) {
    goto restart;
  }
  return tok;
}

void Lexer::Rewind(int64_t rewind_offset) {
  if (rewind_offset < offset_) {
    for (int64_t i = rewind_offset; i < offset_; ++i) {
      if (source_[i] == '\n') {
        line_--;
      }
    }
  } else {
    if (rewind_offset > source_.size()) {
      rewind_offset = source_.size();
    }
    for (int64_t i = offset_; i < rewind_offset; ++i) {
      if (source_[i] == '\n') {
        line_++;
      }
    }
  }
  // Looking for \n before and not at offset_.
  line_offset_ = 1 + source_.find_last_of('\n', offset_ - 1);

  // Scan the next character.
  scan_offset_ = rewind_offset;
  offset_ = rewind_offset;
  if (offset_ < source_.size()) {
    input_rune_ = static_cast<unsigned char>(source_[scan_offset_++]);
  } else {
    input_rune_ = -1;  // Invalid rune for end of input
  }
}

}  // namespace json
